I've got an old self-built frankenstein storage server that runs a **lot** of disks in it. Again, I've installed Ubuntu 18.04 LTS on it and will add as a master node to the cluster to surface up file/block/object storage to workloads.

**NB:** I'm going to use the storage server as a master due to the fact it's one of the device which *should* always be on and running to support other workloads.

## Specs
For reference, here's the specs and parts list.

???+ important "Resource requirements"
    I'll put this here as it burned me originally when setting up the machine. As can be seen from the docs for both [Ceph] and [EdgeFS] the resource requirements for a `proper` production cluster storage solution in Kubernetes can be quite high if you're trying to run hyperconverged hardware (e.g. a homelab environment).

    The rule of thumb is you're looking at a minimum of **1 vCPU** and **1GB RAM** for **each disk**. This became an issue for me once I hit more than 8 disks on a single host with a single Xeon processor. Under the hood Kubernetes (via Rook) is spinning up an OSD container for each disk you have, all of which are running at the same time and requesting those resources be allocated to them. Quite quickly you run into 100% CPU usage on the host and, at times, Out of Memory exceptions with Ceph.

    As a result I've chosen to forgeo the use of Rook in my cluster and revert back to simple NFS sharing. **This is undoubtedly not what you should in production.** I have though, for reference, kept all of my notes for when I choose to upgrade the hardware.

# Setup storage
I'll leave all the disks as standalone JBOD (`J`ust a `B`unch `O`f `D`isks, no RAID) and perform fulldisk encryption such that they have to be unlocked if removed from the server with a key that's held on a separate, removeable, usb stick.

Finding the relevant disks is done with `lsblk`.

??? info "example lsblk"
    I've expanded the `lsblk` command below to add some additional output options to help.

    * `serial`: disk serial number (can be found on the physical disk)
    * `kname`: internal kernel device name
    * `wwn`: unique storage identifier (can be found on the physical disk, seems like not universally implemented by manufacturers)
    * `hotplug`: removable or hotplug device (usb, pcmcia, ...)
    * `rota`: rotational device (i.e. is it spinning rust `hdd` or `ssd`|`nvme`)

    ```bash
    $ lsblk -o +size,serial,kname,wwn,hotplug,rota

    NAME                  MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT   SIZE SERIAL               KNAME     WWN                  HOTPLUG ROTA
    sda                     8:0    0   2.7T  0 disk              2.7T WD-WMC4N0K53DHU      sda       0x50014ee6b0533e3d         0    1
    sdb                     8:16   0 953.9G  0 disk            953.9G 9591205808031        sdb                                  0    0
    sdc                     8:32   0 117.4G  0 disk            117.4G 142433405344         sdc       0x5001b44c354645a0         0    0
    sdd                     8:48   0 953.9G  0 disk            953.9G 9591205808034        sdd                                  0    0
    sde                     8:64   0   2.7T  0 disk              2.7T WD-WCC4N6APEFS4      sde       0x50014ee2605ef68e         0    1
    sdf                     8:80   1  29.3G  0 disk             29.3G 4C530000290829118252 sdf                                  1    1
    └─sdf1                  8:81   1  29.3G  0 part /mnt/key    29.3G                      sdf1                                 1    1
    nvme0n1               259:0    0 119.2G  0 disk            119.2G 9191210606695        nvme0n1   eui.0100000000000000       0    0
    ├─nvme0n1p1           259:1    0   512M  0 part /boot/efi    512M                      nvme0n1p1 eui.0100000000000000       0    0
    └─nvme0n1p2           259:2    0 118.8G  0 part            118.8G                      nvme0n1p2 eui.0100000000000000       0    0
      ├─clarke--vg-root   253:0    0 117.8G  0 lvm  /          117.8G                      dm-0                                 0    0
      └─clarke--vg-swap_1 253:1    0   980M  0 lvm               980M                      dm-1                                 0    0
    ```

    Based on the above output we can see I have:

    * one `hotplug` device (`sdf`) which is the usb with the key on it, mounted to `/mnt/key`
    * two `rotational` devices (`sde`, `sda`) with 2.7TB of capacity
    * three `non-rotational` (i.e. `ssd`) devices with varying capacities (`sdb`, `sdc`, `sdd`)
    * one device (`nvme`) which contains the OS

    As a way of illustration her are pictures of the physcial devices in `sda` and `sdb`.

    ??? example "`sda` 3TB Western Digital Green"
        [WD](img/IMG_0463.jpg)
    
    ??? example "`sdb` KingSpec 1TB SSD"
        [KS](img/IMG_0472.jpg)


# Create a KeyFile
There a a number of different ways to do this. I'd also advise that you perform this on your trusted development machine (and back up the resulting file somewhere...) as opposed to doing all of this on the target host.

```bash
# Create a keyfile (for automounting when plugged in)
# This will take a number of minutes...
dd if=/dev/random of=~/.secretkey bs=1 count=4096
chmod 0400 ~/.secretkey
```

Copy that file onto a `FAT` formatted USB drive. It probably doesn't matter too much what filesystem you use but that has the most common support across Linux, MacOS and Windows.

Now, in the target host, insert the USB and mount it to `/mnt/key` as `read only`.

```bash
sudo mkdir -p /mnt/key
sudo mount -t vfat -o defaults,ro /dev/sdf1 /mnt/key
```

Check this has worked by listing the contents and then attempting to modify the keyfile.

```bash
$ head -n 1 /mnt/key/.secretkey 

M???j[̵s?%?<;?fwefwehwqn??pZ?^o?v?|2?fǄ)?#?%??x*?@.??
??j????/?2?NC?]?{?}thmrtj675?i??CZ&???S?t324t?X?:?R?*?fl98??g?qxcv?n6?loi0;?

$ echo 'test modify' >> /mnt/key/.secretkey

-bash: /mnt/key/.secretkey: Read-only file system
```

Make this persist across reboots by modifying `fstab`. Replace the UUID with the output from `blkid`.

```bash
# Get the UUID of disk
$ blkid /dev/sdf1 -o value -s UUID

FFCA-07F9
```

Now add into fstab so it's mounted every boot.

```bash
# file: /etc/fstab
# Key
UUID=FFCA-07F9    /mnt/key    vfat    defaults,ro    0    1
```

# Configure disks
Rook and Ceph ideally work with blank disks and then take over the management of them, filesystem etc. Whilst we *could* allow Ceph to perform the encryption of the devices automatically I'd like to manage that myself with the physcial key. As a result we'll use `cryptsetup` first on our disks to create a `LUKS` volume that we then later provide to Ceph as the target device using a recent patch for `devicePathFilter` in Rook.

**NB:** There's a [script]() which will do this in an automated fashion in the files section of the repo. The below just covers it in order to explain the steps and process.

## Encrypt with LUKS
```bash
# Set the disk
export d=sdb
export DISK=/dev/${d}

# Reset the disk
sudo wipefs -af /dev/$d

# Encrypt the whole disk (using the keyfile)
sudo cryptsetup luksFormat -q -s 512 -c aes-xts-plain64 -d /mnt/key/.secretkey /dev/$d
```

## Auto-mount encrypted devices at boot
We'll now configure the system to automatically unlock the encrypted partitions on boot. Edit the `/etc/crypttab` file to provide the nexessary information. For that we'll need the `UUID` for each block device which can be found from the `blkid` command. For more details on the principles and processes behind the below see the excellent [Arch Wiki](https://wiki.archlinux.org/index.php/Dm-crypt/System_configuration#crypttab).

>The `/etc/crypttab` (encrypted device table) file is similar to the `fstab` file and contains a list of encrypted devices to be unlocked during system boot up. This file can be used for automatically mounting encrypted swap devices or secondary file systems.
>
>`crypttab` is read before `fstab`, so that `dm-crypt` containers can be unlocked before the file system inside is mounted.

```bash
# Get the blkid of the encrypted disk
export d=sdb
export DISK=/dev/${d}
export BLKID=$(blkid -s UUID -o value /dev/$d)

# Now edit the crypttab
# file: /etc/crypttab
# Fields are: name, underlying device, passphrase, cryptsetup options.
# The below mounts the device with UUID into /dev/mapper/data-<uuid> and unlocks using the secretkey
sudo tee -a /etc/crypttab <<EOF
  data-${BLKID}  UUID=${BLKID}    /mnt/key/.secretkey    luks,retry=1,timeout=180
EOF
```

### Mounting with fstab
#### Using Rook-Ceph
Whilst we could now add the decrypted `/dev/mapper/data-${BLKID}` into `fstab` and mount it somewhere we don't need to for Rook and Ceph, they'll take over from here.

### Using a USB as a KeyFile
As detailed [Unlock LUKS Encrypted Volumes at Boot With a USB Key](https://willhaley.com/blog/unlock-luks-volumes-with-usb-key/)

>There is a bit of a catch here. `/etc/crypttab` is processed before `/etc/fstab`. So `/mnt/key` will not be available at the right time.

What we need to do is create a `/etc/default/cryptdisks` file with the associated mount that needs to be present before processing `/etc/crypttab`.

```bash
sudo tee -a /etc/default/cryptdisks <<EOF
  CRYPTDISKS_MOUNT='/mnt/key'
EOF
```

## Completing
To confirm the above is all working run a `sudo shutdown -r now` in order to prove the devices are decrypted by the key successfully.

# Networking
As I'm using a switch that supports [link aggregation (LACP)](https://en.wikipedia.org/wiki/Link_aggregation) and a server with multiple network interface controllers (NICs) I'll modify the network configuration to take advantage of this.

Create the file `/etc/netplan/config.yaml` with the following in it and then apply the configuration with `sudo netplan apply`, followed by a reboot. Modify as necessary for your setup.

```yaml
# /etc/netplan/config.yaml
# sudo netplan apply
network:
  version: 2
  ethernets:
    eports:
      match:
        name: enp*
      optional: true
  bonds:
    bond0:
      dhcp4: true
      interfaces: [eports]
      # addresses: [192.168.0.111/24]
      # gateway4: 192.168.0.1
      # nameservers:
      #   search: [local]
      #   addresses: [8.8.8.8, 8.8.4.4]
      parameters:
        mode: 802.3ad
        lacp-rate: fast
        transmit-hash-policy: layer2
```

???+ info "Testing network throughput"
    Using `iperf3` you can test that this bonding is working as expected.

    * **mini**: MacMini, single NIC
    * **asimov**: Dell R710, 4xNICs
    * **clarke**: Storage Server, 5xNICs

    With transfers from `clarke` --> `mini` we get the following:

    ```bash
    [ ID] Interval           Transfer     Bandwidth       Retr
    [  4]   0.00-10.00  sec   112 MBytes  94.2 Mbits/sec   64             sender
    [  4]   0.00-10.00  sec   112 MBytes  94.1 Mbits/sec                  receiver
    ```

    With transfers between `clarke` --> `asimov` we get a substantially higher throughput:

    ```bash
    [ ID] Interval           Transfer     Bandwidth       Retr
    [  4]   0.00-10.00  sec  1.00 GBytes   862 Mbits/sec    0             sender
    [  4]   0.00-10.00  sec  1.00 GBytes   862 Mbits/sec                  receiver
    ```

Based on the above performance of `862 Mbits/sec` I'm more likely to get limited by Disk I/O now.